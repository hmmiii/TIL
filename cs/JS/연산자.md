## 연산자의 부수효과(Side Effect)

대부분의 연산자에는 피연산자 그 자체 값이 바뀌는 부수효과가 없다. 하지만 아래 연산자에는 부수효과가 있다.

=, ++, --, delete

## 연산자의 우선순위

연산자의 우선순위는 매우 복잡하고 우선순위를 계산해서 작업시 가독성도 떨어진다. 그룹 연산자`()`를 사용하는 것이 낫다.

## 단항 연산자 +, -

+, - 단항연산자는 값의 부호를 반전해서 반환한다. 부수 효과는 없다.

## 비교 연산자

일반적으로 별 문제 없지만, NaN, 0, -1에서 문제가 발생한다.

```js
NaN === NaN; // false
0 === -0; // true
```

- NaN은 유일하게 원시 값 중에서 자기 자신을 비교할 수 없는 연산자이다.
- 0, -0은 비교시 무조건 true가 나온다.

### Object.is()

이런 경우 Object.is() 메서드를 이용한다.

```js
Object.is(NaN, NaN); // true
Object.is(0, -0); // false
```

## 삼항 연산자

첫 번째 피연산자가 참이면 두 번째 피연산자를 반환, 거짓이면 세 번째 피연산자를 반환한다. 부수효과는 없다.

```js
var a = true
var b = 2
var c = 3

var result = a ? b : c; // 2
```

조건문을 사용할 수도 있겠지만, 조건에 따라 값이 결정되는 간단한 표현식의 경우 삼항연산자는 표현식으로 평가되므로 자주 쓰인다.

## 쉼표 연산자

평가를 수행하고 마지막 피연산자의 결과를 반환한다.

```js
var x, y, z;
x = 1, y = 2, z = 3; // 3
```

## typeof 연산자

- 식별자의 데이터타입을 문자열 타입으로 반환한다. 하지만 7개의 데이터 타입에 완벽하게 똑같이 반환하지 않음을 주의하자.
    - `null`형은 object로 반환된다. 이것은 typeof의 버그이다. 일치 비교 연산인 `===`를 사용하자.
- 객체형은 function을 제외하고(클래스도 funciton으로 반환됨) 모두 object형으로 반환된다.